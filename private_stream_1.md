# private_stream_1数据格式

在[视频文件分段结构](./hiv_mp4_video.md#jump_pes_header)中，说明了所有private_stream_1 PES包都包括header和data两部分，也描述了header部分的含义。本文详细描述data部分含义。

private_stream_1的data部分包含了很多信息，到目前为止只有一小部分可以猜测出含义（GPS、加速度计等），剩余部分仍有待研究。

经过观察，在自定义的data部分，还有一个小header，后文称之为`private_header`。这个private_header之后的data称之为`private_data`，以和PES包的header和data作区分。因此整个PES包的data部分又可以分为两部分：

|  | 内容 |
| ---- | ---- |
| private_header | 包的类型，数据长度等 |
| private_data | 具体数据 |

## private_header

### 总体结构

所有private_stream_1包data的开始部分都有一个长度固定为`0x0C`的private_header。private_header的内容用**大端序**表示，与内部private_data不同。

其结构如下：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 2 | uint16 | 大端序，与数据内容有关，后文称之为`pkt_id` |
| 0x02 | 2 | uint16 | 大端序，数据长度<sup>1</sup>的四分之一，后文称之为`pkt_len` |
| 0x04 | 2 | uint16 | 大端序，与数据内容有关，后文称之为`sub_pkt_id` |
| 0x06 | 6 | NA | 不明，总是`0x81 0x00 0x00 0xFF 0x00 0x00` |

<sup>1</sup> 数据长度，指的是从sub_pkt_id的第1个字节（含）一直到本个private_stream_1包末尾（含）的长度。此处记录了数据长度的四分之一，数据长度总是4的整倍数。

参考[PES_packet_length含义](./hiv_mp4_video.md#jump_pes_len)，可知 $`PES\_packet\_length = pkt\_len * 4 + 14`$

### pkt_id sub_pkt_id含义

pkt_id和sub_pkt_id不同，则private_data所含内容和结构也不同。经过观察，id与内容的对应如下表：

| pkt_id | sub_pkt_id | private_data内容 |
| ---- | ---- | ---- |
| 0x0007 | 0x0001 | [文字格式的加速度计数据](#jump_acce_char) |
| 0x0802 | 0x0007 | [二进制格式加速度计/GPS数据](jump_acce_gps_bin) |
| 0x0802 | 0x0001 | 红绿灯、前车起步、GPS、加速度计等 |
| 0x0009 | 0x0001 | 不明 |

在所有的文件中只观察到了这些pkt_id与sub_pkt_id的组合。下面将按顺序分别对每一种组合详细描述。

## <span id="jump_acce_char">pkt_id=0x0007 sub_pkt_id=0x0001 文字格式加速度计</span>

这类信息以ascii格式记录加速度计数据。可能因为十进制下数字长度会变化，因此这类数据长度也会变化。但是目前观察到长度只可能为`0x9C`或`0x8C`。

结构如下表。偏移量指的是从PES包data开始的偏移量。

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 12 |  | private_header |
| 0x0C | 4 | uint32 | 不明，总是`1` |
| 0x10 | 2 | uint16 | 不明，总是`2` |
| 0x12 | 14 | NA | 不明，总是`0xEE` |
| 0x20 | 4 | uint32 | 不明，总是`0x2C0` |
| 0x24 | 4 | uint32 | 不明，总是`0x240` |
| 0x28 | 2 | uint16 | private_data长度，总是`0x90`或`0x80` |
| 0x2A | 10 | NA | 不明，总是`0x00` |
| ---- | ---- | ---- | ---- |
| 0x34 | 2 | uint16 | 猜测为字符串1长度<sup>1</sup></br>通常为`0x38`或`0x30` |
| 0x36 | 6 | NA | 猜测为字符串1前分隔字节，总是`0x99` |
| 0x3C | 直到下一个`\0`（含） | char[] | 字符串1，时间戳 |
| 可变 | 直到字符串1长度结束 | NA | 猜测为字符串1末尾填充字节</br>通常为`0xAA`或`0x00` |
| ---- | ---- | ---- | ---- |
| 可变 | 2 | uint16 | 猜测为字符串2长度<sup>2</sup></br>通常为`0x38`或`0x30` |
| 可变 | 6 | NA | 猜测为字符串2前分隔字节，总是`0x99` |
| 可变 | 直到下一个`\0`（含） | char[] | 字符串2，加速度计信息 |
| 可变 | 直到包结尾 | NA | 猜测为字符串2末尾填充字节</br>通常为`0xAA`或`0xBB` |

<sup>1</sup> 字符串长度包括字符串长度、字符串前分隔字节、字符串、字符串后填充字节的总长度。

<sup>2</sup> 当包长度为`0x8C`时，字符串2的长度总是会比实际多`0x08`。因此这里猜测的含义仅作为参考。

### <span id="jump_timestamp">内部时间戳</span>

内部时间戳字符串的格式为：

```frmNum=x, timeStamp=y```

x为帧序数，整数。每两个同类数据包之间相隔200毫秒，因此x相差6（假设30fps）。

y为内部时间戳，整数，以毫秒为单位。y与PES_packet header中的[PTS](./hiv_mp4_video.md#jump_pts_timestamp)的关系为 $y = \frac{PTS}{90}$ 。每两个同类数据包之间相隔200毫秒，因此y相差200。

### 加速度计数据

加速度计字符串的格式为：

```g_rt=0 g_x=x g_y=y g_z=z```

g_rt总是为0。推测表示rt表示实时加速度，但是没有计算。

假定行车记录仪正常安装，摄像头朝前：

x为横向加速度，有符号整数，以 $cm \cdot s^{-2}$ 为单位，以左边为正方向。

y为前向加速度，有符号整数，以 $cm \cdot s^{-2}$ 为单位，以前方为正方向。

z为纵向加速度，有符号整数，以 $cm \cdot s^{-2}$ 为单位，以**下**方为正方向。

## <span id="jump_acce_gps_bin">pkt_id=0x0802 sub_pkt_id=0x0007 二进制格式加速度计/GPS</span>

这类信息以二进制格式记录加速度计和GPS的数据。加速度计与GPS数据格式略有不同。

为了区分加速度计数据和GPS数据：观察到GPS的PES包data总是长`0x8C`，而加速度计data总是长`0x84`。此外，偏移量`0x14 - 0x15`处的数据说明了数据包的信息类型，也可以用来区分。

结构如下表。偏移量指的是从PES包data开始的偏移量。

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 12 |  | private_header |
| 0x0C | 4 | NA | 不明，总是`0xFF 0xAA 0xFF 0xAA` |
| 0x10 | 4 | NA | 不明，总是`0xDD 0x2A 0x01 0x02` |
| 0x14 | 2 | uint16 | ***信息类型***</br>0x10：加速度计</br>0x20：GPS |
| 0x16 | 14 | NA | 不明，总是`0x00` |
| 0x24 | 2 | uint16 | 年 |
| 0x26 | 2 | uint16 | 月 |
| 0x28 | 2 | uint16 | 星期几（周日为0，依次增加到周六为6） |
| 0x2A | 2 | uint16 | 日 |
| 0x2C | 2 | uint16 | 时 |
| 0x2E | 2 | uint16 | 分 |
| 0x30 | 2 | uint16 | 秒 |
| 0x32 | 2 | NA | 不明，总是`0x00` |
| 0x34 | 4 | uint32 | [内部时间戳](./hiv_mp4_video.md#jump_pts_timestamp)的整数部分 |
| 0x38 | 4 | uint32 | 猜测为private_header后的private_data长度</br>加速度计：总是`0x78`</br>GPS：总是`0x80` |
| 0x3C | 4 | NA | 不明</br>加速度计：总是`0x05 0x01 0x01 0x01`</br>GPS：总是`0x06 0x06 0x01 0x01` |
| 0x40 | 4 | uint32 | 猜测为data中某一部分长度</br>加速度计：总是`0x48`</br>GPS：总是`0x50` |
| 0x44 | 4 | uint32 | [内部时间戳](./hiv_mp4_video.md#jump_pts_timestamp)的整数部分，和`0x34`处的uint32相同 |
| 0x48 | 2 | uint16 | 数据包编号<sup>1</sup> |
| 0x4A |  |  | 加速度计和GPS后续数据格式有所不同，见后文 |

<sup>1</sup> 每出现一个数据包，编号加一。加速度计和GPS数据包各自独立编号。

### 加速度计二进制数据

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 0x4A |  | 见前文 |
| 0x4A | 30 | NA | 不明，大多数字节都是`0x00` |
| 0x68 | 4 | ***int32*** | z轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以**下**方为正方向 |
| 0x6A | 4 | ***int32*** | y轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以前方为正方向 |
| 0x70 | 4 | ***int32*** | x轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以左方为正方向 |
| 0x74 | 16 | NA | 不明，大多数字节都是`0x00` |

注意这里加速度信息的顺序为 z y x 。

### GPS二进制数据

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 0x4A |  | 见前文 |
| 0x4A | 26 | NA | 不明，大多数字节都是`0x00` |
| 0x64 | 8 | double | 无符号纬度，以度为单位 |
| 0x6C | 8 | double | 无符号经度，以度为单位 |
| 0x74 | 1 | char | 北纬或南纬：</br>`N`：北纬</br>`S`：南纬 |
| 0x75 | 1 | char | 东经或西经：</br>`E`：东经</br>`W`：西经 |
| 0x76 | 1 | uint8 | 是否定位有效：</br>1：定位有效</br>0：定位无效 |
| 0x77 | 1 | NA | 不明，总是`0x00` |
| 0x78 | 4 | float | 车速，以千米每小时为单位 |
| 0x7C | 4 | float | 速度方位角<sup>1</sup>，以度为单位 |
| 0x80 | 12 | NA | 不明，总是`0x00` |

<sup>1</sup> 从天上向下看，从正北顺时针旋转的角度。

### 数据包频率

二进制加速度计数据包没有准确频率，根据观察其频率大约为每秒9个。[文字格式加速度数据](#jump_acce_char)总是来自于之前最近一个二进制数据包的内容。

GPS数据包每秒1个。与市面上大多数GPS模块输出频率相同。

## <span id="jump_misc">pkt_id=0x0802 sub_pkt_id=0x0001 多种数据</span>

这一类数据包最大，内容丰富，但很多数据含义仍然没有猜出。目前观察到的记录内容包括加速度计、GPS、红绿灯位置图像识别、绿灯提醒、前车起步提醒等。

从长度来看，这类数据包似乎只会有三种长度：
- 当停车时，
  - 识别到前车起步/绿灯，其长度为`0x0EE8`
  - 无事发生，其长度为`0x0ED4`
- 当行车时，其长度为`0x0C88`

经过分析，这类数据包中的某些部分长度可变，导致了上述差异。为了便于使用偏移量描述结构，下面将数据包按长度是否可变分为不同的部分：

|  | 长度是否可变 | 长度 | 包含信息 |
| ---- | ---- | ---- | ---- |
| header | 固定 | 0x007C | 是否检测到前车起步/绿灯 |
| part_1 | 可变 | 0x0000：未检测到</br>0x0014：检测到 | 检测到时，前车/绿灯在图像中位置 |
| part_2 | 固定 | 0x01C8 | 二进制加速度计/GPS数据 |
| part_3 | 可变 | [part_3_len](jump_part_3) - 0x0654</br>停车时，总是`0x0640`</br>行车时，总是`0x03F4` | 不明 |
| part_4 | 固定 | 0x017C | 所有检测到的红绿灯在图像中的位置 |
| part_5 | 固定 | 0x0038 | 检测到红灯变绿时，绿灯在图像中位置 |
| part_6 | 固定 | 0x0084 | 之前11个加速度计数据 |
| part_7 | 固定 | 0x0404 | 不明 |
| part_8 | 固定 | 0x0028 | 不明 |

接下来，按照上表的划分，分别描述每一部分的结构。

### header

header长度固定为0x7C。其结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 12 |  | private_header |
| 0x0C | 4 | NA | 不明，总是`0xAA 0xFF 0xAA 0xFF` |
| 0x10 | 4 | NA | 不明，总是`0x00` |
| 0x14 | 2 | uint16 | private_header之后的private_data长度 |
| 0x16 | 10 | NA | 不明，总是</br>`0x00 0x00 0x01 0xFF 0x03 0xFF 0xFF 0xFF 0xFF 0xFF` |
| 0x20 | 2 | uint16 | private_header之后的private_data长度 |
| 0x22 | 6 | NA | 不明，总是</br>`0x1B 0x0F 0x1B 0x23 0x0B 0x00` |
| 0x28 | 4 | uint32 | [frmNum](#jump_timestamp) |
| 0x2C | 4 | uint32 | [timeStamp](#jump_timestamp) |
| 0x30 | 4 | NA | 不明，总是`0xFF` |
| 0x34 | 2 | NA | ***图像识别结果***</br>`0x00 0x07`：停车无事发生/行车</br>`0x01 0x07`：绿灯/前车起步 |
| 0x36 | 2 | NA | 不明，总是`0xFF` |
| 0x38 | 4 | NA | `0x00 0x00 0x00 0x00`：停车无事发生/行车</br>`0x08 0x00 0x00 0x00`：绿灯/前车起步 |
| 0x3C | 8 | NA | 不明，总是`0xFF` |
| 0x44 | 2 | NA | ***图像识别类型***</br>`0x01 0x00`：停车无事发生/行车</br>`0x02 0x00`：停车无事发生/行车</br>`0x22 0x00`：绿灯</br>`0x21 0x00`：前车起步 |
| 0x44 | 0x38 | NA | 不明 |

header中主要提供的信息是`0x34`处的**图像识别结果**和0x44处的**图像识别类型**。

图像识别结果将决定part_1是否存在。图像识别类型将说明part_1中描述的位置是刚变绿的红绿灯还是刚起步的前车。

### <span id="jump_part_1">part_1</span>

part_1长度可变。当图像识别到绿灯/前车起步时，part_1存在，长度0x14。part_1中的信息描述了被识别到的物体在画面中的位置，以一个能框住被识别物的方框坐标表示。

part_1结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 2 | uint16 | 方框左上角x坐标<sup>1</sup> |
| 0x02 | 2 | uint16 | 方框左上角y坐标 |
| 0x04 | 2 | uint16 | 方框x轴宽度 |
| 0x06 | 2 | uint16 | 方框y轴高度 |
| 0x08 | 12 | NA | 不明 |

<sup>1</sup> 以画面左上角为原点，x轴向右为正，y轴向下为正。所有位置都以像素为单位。

### <span id="jump_part_2">part_2</span>

part_2长度固定为0x1C8。其内容复杂，目前可以猜出的仅有加速度计和GPS数据。

part_2结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x000 | 0x100 | NA | 不明 |
| 0x100 | 4 | ***int32*** | z轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以**下**方为正方向 |
| 0x104 | 4 | ***int32*** | y轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以前方为正方向 |
| 0x108 | 4 | ***int32*** | x轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以左方为正方向 |
| 0x10C | 12 | NA | 不明，总是`0x00` |
| 0x118 | 8 | double | 无符号纬度，以度为单位 |
| 0x120 | 8 | double | 无符号经度，以度为单位 |
| 0x128 | 8 | NA | 不明，总是`0x00` |
| 0x130 | 8 | double | 车速，以千米每小时为单位，总是整数 |
| 0x138 | 8 | NA | 不明，总是`0x00` |
| 0x140 | 8 | double | 速度方位角，以度为单位，总是整数 |
| 0x148 | 0x30 | NA | 不明，总是`0x00` |

观察发现这里的加速度和GPS数据都分别来自上一个[二进制格式加速度计/GPS数据包](#jump_acce_gps_bin)。这里没有找到表示南北纬、东西经的字节。注意这里加速度信息的顺序为 z y x 。

### <span id="jump_part_3">part_3</span>

这一部分长度可变。停车时长为0x640，行车时长为0x3F4，相差了0x24C。其内容含义不明。

part_3长度总是`part_3_len - 0x654`。`part_3_len`定义见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 2 | uint16 | **part_3_len** |
| 0x2 | 到结尾，`part_3_len - 0x656` | NA | 不明 |

### part_4

part_4长度固定为0x17C。这一部分包括了检测到的画面中所有红绿灯的位置，同样是以方框形式表示。

part_4结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x000 | 4 | uint32 | 上一个此类PES包的[内部时间戳](#jump_timestamp) |
| 0x004 | 4 | uint32 | 本个PES包的内部时间戳<sup>1</sup> |
| 0x008 | 4 | uint32 | 上一次停车时的内部时间戳 |
| 0x00C | 4 | uint32 | 不明，通常是1，也可能是2 |
| 0x010 | 8 |  | 第1个框的位置信息 |
| 0x018 | 8 |  | 第2个框的位置信息 |
| ... | 8 | ... | ... |
| 0x170 | 8 |  | 第45个框的位置信息 |
| 0x178 | 4 | uint32 | 框的数量`rec_num` |

<sup>1</sup> 由于pkt_id=0x0802 sub_pkt_id=0x0001这类PES包每200ms产生一个，因此前后两个数据包内部时间戳总是相差200。

`rec_num`决定了part_4中有效的框的个数。虽然part_4中最多可以描述45个框，但是只有前`rec_num`个框的位置信息是有效的。

框的位置信息结构类似[part_1](#jump_part_1)，但是其坐标都需要乘以1.5。具体见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 2 | uint16 | 乘以1.5之后表示框左上角x坐标<sup>1</sup> |
| 0x2 | 2 | uint16 | 乘以1.5之后表示框左上角y坐标 |
| 0x4 | 2 | uint16 | 乘以1.5之后表示框宽度 |
| 0x6 | 2 | uint16 | 乘以1.5之后表示框高度 |

<sup>1</sup> 坐标定义同[part_1](#jump_part_1)。

part_4中识别到的红绿灯位置仅会在停车时更新，汽车起步后这些信息一直保持不变。

另外观察到记录仪仅会把识别地平线以上的物体识别为红绿灯。

### part_5

part_5长度固定为0x38。这一部分信息很多，但是只能猜出某一部分代表了红绿灯在画面中的位置，同样以画面中方框表示。

part_5结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 16 | NA | 不明 |
| 0x10 | 4 | uint32 | 本个PES包的[内部时间戳](#jump_timestamp) |
| 0x14 | 4 | NA | 不明 |
| 0x18 | 2 | uint16 | 乘以1.5之后表示框左上角x坐标<sup>1</sup> |
| 0x1A | 2 | uint16 | 乘以1.5之后表示框左上角y坐标 |
| 0x1C | 2 | uint16 | 乘以1.5之后表示框宽度 |
| 0x1E | 2 | uint16 | 乘以1.5之后表示框高度 |
| 0x20 | 24 | NA | 不明 |

<sup>1</sup> 坐标定义同[part_1](#jump_part_1)。

只有检测到红灯变绿的数据包会包含红绿灯位置，否则框信息处全为`0x00`。此处的红绿灯位置乘以1.5，再截断取整后，即与part_1中位置信息相同。

### part_6

part_6长度固定为0x84。其中包括了从前面第12个到前面第2个，共计11个二进制加速度计数据包。

part_6结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 12 |  | 前面第12个二进制加速度信息 |
| 0x0C | 12 |  | 前面第11个二进制加速度信息 |
| ... | ... | ... | ... |
| 0x78 | 12 |  | 前面第2个二进制加速度信息 |

二进制加速度信息结构如下：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 4 | ***int32*** | x轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以左方为正方向 |
| 0x4 | 4 | ***int32*** | y轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以前方为正方向 |
| 0x8 | 4 | ***int32*** | z轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以**下**方为正方向 |

注意这里加速度信息的顺序为 x y z 。

part_6中的前12~前2个加速度信息与[part_2](#jump_part_2)中的前1个加速度信息合在一起构成了本PES包前12个二进制加速度历史数据。

### part_7

part_7长度固定为0x404。其含义不明，但是可以观察到内部的结构。

part_7内部有两个长度相同的数组，数组的每个元素为两个float构成的结构体。

part_7结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x000 | 4 | uint32 | 每个数组内元素个数`arr_len` |
| 0x004 | 0x200 | array | 数组0 |
| 0x204 | 0x200 | array | 数组1 |

数组结构为：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 8 | struct | 元素0 |
| 0x8 | 8 | struct | 元素1 |
| ... | 8 | struct | ... |
| `(arr_len-1)*8` | 8 | struct | 元素`arr_len - 1` |

元素`arr_len - 1`之后的数据全为`0x00`。

每个数组元素结构为：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 4 | float | float0 |
| 0x4 | 4 | float | float1 |

通过python绘图，观察到两个数组内相同位置的数值非常相似，但不相等。float0始终在0.54附近波动，float1随着下标增加均匀地从0增加到1。其含义不明。

### part_8

part_8长度固定为0x28。其含义不明。结构为：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 4 | float | 不明 |
| 0x04 | 4 | float | 不明 |
| 0x08 | 4 | NA | 不明，总是`0x00` |
| 0x0C | 4 | uint32 | [frmNum](#jump_timestamp) |
| 0x10 | 24 | NA | 不明 |
