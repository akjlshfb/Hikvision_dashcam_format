# <span id="jump_misc_1">pkt_id=0x0802 sub_pkt_id=0x0001 多种数据</span>

这一类数据包最大，内容丰富，但很多数据含义仍然没有猜出。目前观察到的记录内容包括加速度计、GPS、红绿灯位置图像识别、绿灯提醒、前车起步提醒等。这类数据包的频率固定为5个每秒。

从长度来看，这类数据包似乎只会有三种长度：
- 当停车时，
  - 识别到前车起步/绿灯，其长度为`0x0EE8`
  - 无事发生，其长度为`0x0ED4`
- 当行车时，其长度为`0x0C88`

经过分析，这类数据包中的某些部分长度可变，导致了上述差异。为了便于使用偏移量描述结构，下面将数据包按长度是否可变分为不同的部分：

|  | 长度是否可变 | 长度 | 包含信息 |
| ---- | ---- | ---- | ---- |
| [header](#jump_header) | 固定 | 0x0068 | 是否检测到前车起步/绿灯 |
| [part_1](#jump_part_1) | 可变 | 0x0000：未检测到</br>0x0014：检测到 | 检测到时，前车/绿灯在图像中位置 |
| [part_2](#jump_part_2) | 固定 | 0x01C0 | 二进制加速度计/GPS数据 |
| [part_3](#jump_part_3) | 可变 | [part_3_len](#jump_part_3) - 0x064C</br>停车时，总是`0x0648`</br>行车时，总是`0x03FC` | 不明 |
| [part_4](#jump_part_4) | 固定 | 0x017C | 所有检测到的红绿灯在图像中的位置 |
| [part_5](#jump_part_5) | 固定 | 0x0038 | 检测到红灯变绿时，绿灯在图像中位置 |
| [part_6](#jump_part_6) | 固定 | 0x0084 | 之前11个加速度计数据 |
| [part_7](#jump_part_7) | 固定 | 0x0404 | 不明 |
| [part_8](#jump_part_8) | 固定 | 0x0028 | 不明 |

接下来，按照上表的划分，分别描述每一部分的结构。

## <span id="jump_header">header</span>

header长度固定为0x68。其结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 12 |  | private_header |
| 0x0C | 4 | NA | 不明，总是`0xAA 0xFF 0xAA 0xFF` |
| 0x10 | 4 | NA | 不明，总是`0x00` |
| 0x14 | 2 | uint16 | private_header之后的private_data长度 |
| 0x16 | 10 | NA | 不明，总是</br>`0x00 0x00 0x01 0xFF 0x03 0xFF 0xFF 0xFF 0xFF 0xFF` |
| 0x20 | 2 | uint16 | private_header之后的private_data长度 |
| 0x22 | 6 | NA | 不明，总是</br>`0x1B 0x0F 0x1B 0x23 0x0B 0x00` |
| 0x28 | 4 | uint32 | [frmNum](./private_ascii_acce.md#jump_timestamp) |
| 0x2C | 4 | uint32 | [timeStamp](./private_ascii_acce.md#jump_timestamp) |
| 0x30 | 4 | NA | 不明，总是`0xFF` |
| 0x34 | 2 | NA | ***图像识别结果***</br>`0x00 0x07`：停车无事发生/行车</br>`0x01 0x07`：绿灯/前车起步 |
| 0x36 | 2 | NA | 不明，总是`0xFF` |
| 0x38 | 4 | NA | `0x00 0x00 0x00 0x00`：停车无事发生/行车</br>`0x08 0x00 0x00 0x00`：绿灯/前车起步 |
| 0x3C | 8 | NA | 不明，总是`0xFF` |
| 0x44 | 2 | NA | ***图像识别类型***</br>`0x01 0x00`：停车无事发生/行车</br>`0x02 0x00`：停车无事发生/行车</br>`0x22 0x00`：绿灯</br>`0x21 0x00`：前车起步 |
| 0x46 | 34 | NA | 不明 |

header中主要提供的信息是`0x34`处的**图像识别结果**和0x44处的**图像识别类型**。

图像识别结果将决定part_1是否存在。仅当图像识别结果为`0x01 0x07`时，part_1存在。

## <span id="jump_part_1">part_1</span>

part_1长度可变。仅当图像识别到绿灯/前车起步时，part_1存在，长度为0x14。part_1中的信息描述了被识别到的物体在画面中的位置，以一个能框住被识别物的方框坐标表示。

part_1结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 2 | uint16 | 方框左上角x坐标<sup>1</sup> |
| 0x02 | 2 | uint16 | 方框左上角y坐标 |
| 0x04 | 2 | uint16 | 方框x轴宽度 |
| 0x06 | 2 | uint16 | 方框y轴高度 |
| 0x08 | 12 | NA | 不明 |

<sup>1</sup> 以画面左上角为原点，x轴向右为正，y轴向下为正。所有位置都以像素为单位。

header中的图像识别类型将说明part_1中被框住的物体。图像识别类型为`0x21 0x00`时，框住的是画面中前一辆汽车；为`0x22 0x00`时，框住的是变绿的红绿灯。

## <span id="jump_part_2">part_2</span>

part_2长度固定为0x1C0。其内容复杂，目前可以猜出的仅有加速度计和GPS数据。

part_2结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x000 | 0x100 | NA | 不明 |
| 0x100 | 4 | ***int32*** | z轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以**下**方为正方向 |
| 0x104 | 4 | ***int32*** | y轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以前方为正方向 |
| 0x108 | 4 | ***int32*** | x轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以左方为正方向 |
| 0x10C | 12 | NA | 不明，总是`0x00` |
| 0x118 | 8 | double | 无符号纬度，以度为单位 |
| 0x120 | 8 | double | 无符号经度，以度为单位 |
| 0x128 | 8 | NA | 不明，总是`0x00` |
| 0x130 | 8 | double | 车速，以千米每小时为单位，总是整数 |
| 0x138 | 8 | NA | 不明，总是`0x00` |
| 0x140 | 8 | double | 速度方位角，以度为单位，总是整数 |
| 0x148 | 120 | NA | 不明，几乎都是`0x00` |

观察发现这里的加速度和GPS数据都分别来自上一个[二进制格式加速度计/GPS数据包](./private_bin_acce_gps.md)。这里没有找到表示南北纬、东西经的字节。注意这里加速度信息的顺序为 z y x 。

## <span id="jump_part_3">part_3</span>

这一部分长度可变。停车时长为0x648，行车时长为0x3FC，相差了0x24C。其内容含义不明。

part_3长度总是`part_3_len - 0x64C`。`part_3_len`定义见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 4 | uint32 | 本个PES包的[内部时间戳](./private_ascii_acce.md#jump_timestamp) |
| 0x4 | 4 | NA | 不明 |
| 0x8 | 2 | uint16 | ***part_3_len*** |
| 0xA | 一直到part_3结尾</br>`part_3_len - 0x65A` | NA | 不明 |

## <span id="jump_part_4">part_4</span>

part_4长度固定为0x17C。这一部分包括了检测到的画面中所有红绿灯的位置，同样是以方框形式表示。

part_4结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x000 | 4 | uint32 | 上一个此类PES包的[内部时间戳](./private_ascii_acce.md#jump_timestamp) |
| 0x004 | 4 | uint32 | 本个PES包的内部时间戳<sup>1</sup> |
| 0x008 | 4 | uint32 | 上一次停车时的内部时间戳 |
| 0x00C | 4 | uint32 | 不明，通常是1，也可能是2 |
| 0x010 | 8 |  | 第1个框的位置信息 |
| 0x018 | 8 |  | 第2个框的位置信息 |
| ... | 8 | ... | ... |
| 0x170 | 8 |  | 第45个框的位置信息 |
| 0x178 | 4 | uint32 | 框的数量`rec_num` |

<sup>1</sup> 由于pkt_id=0x0802 sub_pkt_id=0x0001这类PES包每200ms产生一个，因此前后两个数据包内部时间戳总是相差200。

`rec_num`决定了part_4中有效的框的个数。虽然part_4中最多可以描述45个框，但是只有前`rec_num`个框的位置信息是有效的。

框的位置信息结构类似[part_1](#jump_part_1)，但是其坐标都需要乘以1.5。具体见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 2 | uint16 | 乘以1.5之后表示框左上角x坐标<sup>1</sup> |
| 0x2 | 2 | uint16 | 乘以1.5之后表示框左上角y坐标 |
| 0x4 | 2 | uint16 | 乘以1.5之后表示框宽度 |
| 0x6 | 2 | uint16 | 乘以1.5之后表示框高度 |

<sup>1</sup> 坐标定义同[part_1](#jump_part_1)。

part_4中识别到的红绿灯位置仅会在停车时更新，汽车起步后这些信息一直保持不变。

另外观察到记录仪仅会把识别地平线以上的物体识别为红绿灯。

## <span id="jump_part_5">part_5</span>

part_5长度固定为0x38。这一部分信息很多，但是只能猜出某一部分代表了红绿灯在画面中的位置，同样以画面中方框表示。

part_5结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 16 | NA | 不明 |
| 0x10 | 4 | uint32 | 本个PES包的[内部时间戳](./private_ascii_acce.md#jump_timestamp) |
| 0x14 | 4 | NA | 不明 |
| 0x18 | 2 | uint16 | 乘以1.5之后表示框左上角x坐标<sup>1</sup> |
| 0x1A | 2 | uint16 | 乘以1.5之后表示框左上角y坐标 |
| 0x1C | 2 | uint16 | 乘以1.5之后表示框宽度 |
| 0x1E | 2 | uint16 | 乘以1.5之后表示框高度 |
| 0x20 | 24 | NA | 不明 |

<sup>1</sup> 坐标定义同[part_1](#jump_part_1)。

只有检测到红灯变绿的数据包会包含红绿灯位置，否则框信息处全为`0x00`。此处的红绿灯位置乘以1.5，再截断取整后，即与part_1中位置信息相同。

## <span id="jump_part_6">part_6</span>

part_6长度固定为0x84。其中包括了从前面第12个到前面第2个，共计11个二进制加速度计数据包。

part_6结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 12 |  | 前面第12个二进制加速度信息 |
| 0x0C | 12 |  | 前面第11个二进制加速度信息 |
| ... | ... | ... | ... |
| 0x78 | 12 |  | 前面第2个二进制加速度信息 |

二进制加速度信息结构如下：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 4 | ***int32*** | x轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以左方为正方向 |
| 0x4 | 4 | ***int32*** | y轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以前方为正方向 |
| 0x8 | 4 | ***int32*** | z轴加速度，***有符号***，以 $cm \cdot s^{-2}$ 为单位，以**下**方为正方向 |

注意这里加速度信息的顺序为 x y z 。

part_6中的前12~前2个加速度信息与[part_2](#jump_part_2)中的前1个加速度信息合在一起构成了本PES包前12个二进制加速度历史数据。

## <span id="jump_part_7">part_7</span>

part_7长度固定为0x404。其含义不明，但是可以观察到内部的结构。

part_7内部有两个长度相同的数组，数组的每个元素为两个float构成的结构体。

part_7结构见下表：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x000 | 4 | uint32 | 每个数组内元素个数`arr_len` |
| 0x004 | 0x200 | array | 数组0 |
| 0x204 | 0x200 | array | 数组1 |

数组结构为：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 8 | struct | 元素0 |
| 0x8 | 8 | struct | 元素1 |
| ... | 8 | struct | ... |
| `(arr_len-1)*8` | 8 | struct | 元素`arr_len - 1` |

元素`arr_len - 1`之后的数据全为`0x00`。

每个数组元素结构为：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x0 | 4 | float | float0 |
| 0x4 | 4 | float | float1 |

通过python绘图，观察到两个数组内相同位置的数值非常相似，但不相等。float0始终在0.54附近波动，float1随着下标增加均匀地从0增加到1。其含义不明。

## <span id="jump_part_8">part_8</span>

part_8长度固定为0x28。其含义不明。结构为：

| 偏移量 | 字节数 | 类型 | 猜测含义 |
| ---- | ---- | ---- | ---- |
| 0x00 | 4 | float | 不明 |
| 0x04 | 4 | float | 不明 |
| 0x08 | 4 | NA | 不明，总是`0x00` |
| 0x0C | 4 | uint32 | [frmNum](./private_ascii_acce.md#jump_timestamp) |
| 0x10 | 24 | NA | 不明 |

<br/><br/>
返回[private_stream_1数据格式](./private_stream_1.md)
